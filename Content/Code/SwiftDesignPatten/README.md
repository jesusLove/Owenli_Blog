

#  设计模式

`Swift` 实现设计模式

参考：[SwiftGG翻译](https://swift.gg)

1. [Swift 中的设计模式 #1 工厂方法与单例方法](https://swift.gg/2018/09/10/design-pattern-creational/)
2. [Swift 中的设计模式 #2 观察者模式与备忘录模式](https://swift.gg/2018/11/26/design-pattern-behavorial/)
3. [Swift 中的设计模式 #3 外观模式与适配器模式](https://swift.gg/2018/11/29/design-pattern-structural/)

 23 种设计模式整理到了 3 种大的类别中：“创建型模式”、“结构型模式”以及“行为型模式”。
 
# 创建型模式

## 工厂模式

例子：

1. `HelperViewFactoryProtocol`用于在视图控制器内绘制形状的协议。
2. `Square`: 是一个正方遵循上述协议
3. `Circle`和`Rectrangle`都是`Square`的特殊子类。
4. `ShapeFactory`：工厂类，用于生成不同的形式。

## 单例模式

以 用户偏好 类为例。`UserPreferences`全局管理状态。


# 行为型模式
>  行为型模式的主要作用是对类和结构体（参与者）的行为赋予安全性、合理性，以及定义一些统一的规则、统一的的形式和最佳实践。对于整个应用中的参与者，我们都希望有一个良好的、统一的、并且可预测的行为。同时，我们不仅希望参与者本身拥有良好的行为，也希望不同的参与者之间的交互/通信可以拥有良好的行为。对于参与者的行为评估，其时机应该在编译之前以及编译时 —— 我通常把这段时间称之为“设计时间”，以及在运行时 —— 此时我们会有大量的类和结构体的实例在各司其职或与其他实例交互/通信。由于实例间的通信会导致软件复杂度的增加，因此制定一系列关于一致性、高效率和安全通信的规则是极为重要的，但与此同时，在构建每个单独的参与者时，这个概念不应以任何方式降低设计的质量。由于需要非常着重于行为，我们必须牢记一点 —— 在赋予参与者职责时必须使用一致的模式。

## 观察者模式

一种`松耦合`的模式。iOS内置的观察者：`NotificationCenter`。

> 被观察的实例（通常是一个重要的资源）会广播关于自身状态改变的通知给其他众多观察者实例。对这些状态改变有兴趣的观察者必须通过订阅来获取关于状态改变通知。

> 假设我们有一个工具来监视网络连接状况，并对已连接或未连接的状态作出响应。这个工具我们可以称之为广播者。为了实现此工具，你需要一个参与者遵循我提供的 ObservedProtocol 协议。虽然我知道这么做并不太符合苹果的 iOS Human Interface Guideline 的建议，但我为了更好地演示观察者模式，我需要以网络状况作为仅有的一个关键资源。

## 备忘录模式

> 我所实现的备忘录模式非常直白。代码中包含了一个 Memento 协议，以及 Memento 协议的扩展，用于在成员属性中存在遵循 Memento 协议的属性时，处理和抽象关于归档与解档的逻辑。与此同时，这个协议扩展允许在任何时候打印实例的所有状态。我使用了一个 Dictionary<String, String> 来存储那些遵循协议的类中的属性 —— 属性名作为字典的 Key，属性值作为字典的 Value。我把属性的值以字符串的类型存储，以此达到代码较简洁且容易理解的目的，但我必须承认实际情况中有许多用例会要求你去操作非常复杂的属性类型。归根到底，这是一个关于设计模式的教程，因此没有任何代码是基于生产环境来编写的。

>需要注意我为 Memento 协议加了一个 persist() 方法和一个 recover() 方法，任何遵循此协议的类都必须实现它们。这两个方法让开发者可以根据实际需要，通过名字来归档和解档某个遵循 Memento 协议的类中的特定属性。换句话说，Memento 中类型为 Dictionary<String, String> 的 state 属性可以一对一地对应到某个遵循此协议的类中的属性，这些属性的名称对应字典中元素的 key，属性的值对应字典中元素的 value。相信你在看完具体的代码后肯定能完全理解。

>由于遵循 Memento 协议的类必须实现 persist() 和 recover() 方法，因此这两个方法必须可以访问所有可见的属性，无论它具有什么样的访问权限 —— public 、private 还是 fileprivate。

>你或许也想知道我为什么把 Memento 协议设置为类协议（class-only）。原因仅仅是因为 Swift 编译器那诡异的报错：”Cannot use mutating member on immutable value: ‘self’ is immutable”。我们暂且不讨论这个问题，因为它远远超出了本次教程的范围。如果你对这个问题感兴趣，你可以看一下这个 不错的解释。

# 结构型模式



